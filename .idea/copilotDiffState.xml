<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/chenhongyu/huajuan/render/HtmlRenderer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/chenhongyu/huajuan/render/HtmlRenderer.kt" />
              <option name="originalContent" value="package com.chenhongyu.huajuan.render&#10;&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.Canvas&#10;import android.util.Log&#10;import android.view.View&#10;import android.webkit.WebSettings&#10;import android.webkit.WebView&#10;import android.webkit.WebViewClient&#10;import kotlinx.coroutines.CompletableDeferred&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.GlobalScope&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import org.json.JSONObject&#10;&#10;object HtmlRenderer {&#10;    private const val TAG = &quot;HtmlRenderer&quot;&#10;&#10;    // Safety limits to avoid OOM. Adjust to your needs / device memory.&#10;    private const val MAX_WIDTH_PX = 2048&#10;    private const val MAX_HEIGHT_PX = 8192&#10;    private const val BYTES_PER_PIXEL = 4 // ARGB_8888&#10;&#10;    /**&#10;     * Render the provided HTML string into a Bitmap. Must be called from a coroutine.&#10;     * This function will switch to the Main dispatcher for WebView operations.&#10;     * Returns the Bitmap on success or throws an exception on failure.&#10;     */&#10;    suspend fun renderHtmlToBitmap(&#10;        context: Context,&#10;        html: String,&#10;        targetWidthPx: Int,&#10;        backgroundColor: Int = 0xFFFFFFFF.toInt(),&#10;        scaleDownIfTooLarge: Boolean = true&#10;    ): Bitmap = withContext(Dispatchers.Main) {&#10;        val deferred = CompletableDeferred&lt;Bitmap&gt;()&#10;&#10;        try {&#10;            val webView = WebView(context)&#10;            // Basic settings&#10;            webView.settings.apply {&#10;                javaScriptEnabled = true // enable JS: template uses marked.js and we use evaluateJavascript&#10;                domStorageEnabled = true&#10;                useWideViewPort = true&#10;                loadWithOverviewMode = true&#10;                // allow file access for local assets if needed&#10;                allowFileAccess = true&#10;                // allowMixedContent for loading remote fonts/resources if needed&#10;                if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) {&#10;                    mixedContentMode = WebSettings.MIXED_CONTENT_COMPATIBILITY_MODE&#10;                }&#10;            }&#10;&#10;            webView.isVerticalScrollBarEnabled = false&#10;            webView.isHorizontalScrollBarEnabled = false&#10;&#10;            webView.webViewClient = object : WebViewClient() {&#10;                override fun onPageFinished(view: WebView?, url: String?) {&#10;                    super.onPageFinished(view, url)&#10;                    try {&#10;                        // get content height (in CSS px) and devicePixelRatio&#10;                        view?.evaluateJavascript(&#10;                            &quot;(function(){return {h: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight), d: window.devicePixelRatio||1};})()&quot;&#10;                        ) { result -&gt;&#10;                            try {&#10;                                if (result == null) {&#10;                                    deferred.completeExceptionally(RuntimeException(&quot;Empty JS result&quot;))&#10;                                } else {&#10;                                    val cleaned = result.trim()&#10;                                    // parse json result&#10;                                    val obj = JSONObject(cleaned)&#10;                                    val cssHeight = obj.optInt(&quot;h&quot;, 0)&#10;                                    val dpr = obj.optDouble(&quot;d&quot;, 1.0).toFloat()&#10;&#10;                                    val contentHeightPx = (cssHeight * dpr).toInt()&#10;&#10;                                    var widthPx = targetWidthPx.coerceAtMost(MAX_WIDTH_PX)&#10;                                    var heightPx = contentHeightPx.coerceAtMost(MAX_HEIGHT_PX)&#10;&#10;                                    if (scaleDownIfTooLarge) {&#10;                                        // if content is taller than max, scale down both dimensions proportionally&#10;                                        if (contentHeightPx &gt; MAX_HEIGHT_PX) {&#10;                                            val scale = MAX_HEIGHT_PX.toFloat() / contentHeightPx.toFloat()&#10;                                            widthPx = (widthPx * scale).toInt().coerceAtLeast(1)&#10;                                            heightPx = MAX_HEIGHT_PX&#10;                                        }&#10;                                    } else {&#10;                                        if (contentHeightPx &gt; MAX_HEIGHT_PX) {&#10;                                            deferred.completeExceptionally(RuntimeException(&quot;Rendered content too tall: $contentHeightPx px&quot;))&#10;                                            return@evaluateJavascript&#10;                                        }&#10;                                    }&#10;&#10;                                    try {&#10;                                        // measure &amp; layout&#10;                                        val widthSpec = View.MeasureSpec.makeMeasureSpec(widthPx, View.MeasureSpec.EXACTLY)&#10;                                        val heightSpec = View.MeasureSpec.makeMeasureSpec(heightPx, View.MeasureSpec.EXACTLY)&#10;                                        view.measure(widthSpec, heightSpec)&#10;                                        view.layout(0, 0, widthPx, heightPx)&#10;&#10;                                        // create bitmap and draw&#10;                                        val estimatedBytes = widthPx.toLong() * heightPx.toLong() * BYTES_PER_PIXEL&#10;                                        // crude safety check: avoid allocating beyond a large threshold (~200MB)&#10;                                        if (estimatedBytes &gt; 200L * 1024 * 1024) {&#10;                                            deferred.completeExceptionally(RuntimeException(&quot;Bitmap too large to allocate: bytes=$estimatedBytes&quot;))&#10;                                            return@evaluateJavascript&#10;                                        }&#10;&#10;                                        val bitmap = Bitmap.createBitmap(widthPx, heightPx, Bitmap.Config.ARGB_8888)&#10;                                        val canvas = Canvas(bitmap)&#10;                                        canvas.drawColor(backgroundColor)&#10;                                        view.draw(canvas)&#10;&#10;                                        // finish&#10;                                        deferred.complete(bitmap)&#10;                                    } catch (e: Throwable) {&#10;                                        deferred.completeExceptionally(e)&#10;                                    }&#10;                                }&#10;                            } catch (e: Throwable) {&#10;                                deferred.completeExceptionally(e)&#10;                            } finally {&#10;                                // cleanup WebView to avoid leak&#10;                                try {&#10;                                    view?.stopLoading()&#10;                                    view?.loadUrl(&quot;about:blank&quot;)&#10;                                    view?.removeAllViews()&#10;                                    view?.destroy()&#10;                                } catch (t: Throwable) {&#10;                                    Log.w(TAG, &quot;Error destroying WebView&quot;, t)&#10;                                }&#10;                            }&#10;                        }&#10;                    } catch (e: Throwable) {&#10;                        deferred.completeExceptionally(e)&#10;                    }&#10;                }&#10;            }&#10;&#10;            // load HTML. Use baseUrl null; callers can embed asset references using file:///android_asset/&#10;            webView.loadDataWithBaseURL(null, html, &quot;text/html&quot;, &quot;utf-8&quot;, null)&#10;&#10;        } catch (e: Throwable) {&#10;            deferred.completeExceptionally(e)&#10;        }&#10;&#10;        deferred.await()&#10;    }&#10;&#10;    /**&#10;     * Java/callback friendly API. Runs on Main thread internally but returns on caller thread via callback.&#10;     */&#10;    fun renderHtmlToBitmapAsync(&#10;        context: Context,&#10;        html: String,&#10;        targetWidthPx: Int,&#10;        onResult: (result: Result&lt;Bitmap&gt;) -&gt; Unit&#10;    ) {&#10;        GlobalScope.launch(Dispatchers.Main) {&#10;            try {&#10;                val bmp = renderHtmlToBitmap(context, html, targetWidthPx)&#10;                onResult(Result.success(bmp))&#10;            } catch (e: Throwable) {&#10;                onResult(Result.failure(e))&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chenhongyu.huajuan.render&#10;&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.Canvas&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.util.Log&#10;import android.view.View&#10;import android.webkit.RenderProcessGoneDetail&#10;import android.webkit.WebSettings&#10;import android.webkit.WebView&#10;import android.webkit.WebViewClient&#10;import kotlinx.coroutines.CompletableDeferred&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.GlobalScope&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import org.json.JSONObject&#10;import java.util.concurrent.TimeoutException&#10;&#10;object HtmlRenderer {&#10;    private const val TAG = &quot;HtmlRenderer&quot;&#10;&#10;    // Safety limits to avoid OOM. Adjust to your needs / device memory.&#10;    private const val MAX_WIDTH_PX = 2048&#10;    private const val MAX_HEIGHT_PX = 8192&#10;    private const val BYTES_PER_PIXEL = 4 // ARGB_8888&#10;    private const val RENDER_TIMEOUT_MS = 15_000L&#10;&#10;    /**&#10;     * Render the provided HTML string into a Bitmap. Must be called from a coroutine.&#10;     * This function will switch to the Main dispatcher for WebView operations.&#10;     * Returns the Bitmap on success or throws an exception on failure.&#10;     */&#10;    suspend fun renderHtmlToBitmap(&#10;        context: Context,&#10;        html: String,&#10;        targetWidthPx: Int,&#10;        backgroundColor: Int = 0xFFFFFFFF.toInt(),&#10;        scaleDownIfTooLarge: Boolean = true&#10;    ): Bitmap = withContext(Dispatchers.Main) {&#10;        val deferred = CompletableDeferred&lt;Bitmap&gt;()&#10;&#10;        try {&#10;            val webView = WebView(context)&#10;            // Basic settings&#10;            webView.settings.apply {&#10;                javaScriptEnabled = true // enable JS: template uses marked.js and we use evaluateJavascript&#10;                domStorageEnabled = true&#10;                useWideViewPort = true&#10;                loadWithOverviewMode = true&#10;                // allow file access for local assets if needed&#10;                allowFileAccess = true&#10;                // allowMixedContent for loading remote fonts/resources if needed&#10;                if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) {&#10;                    mixedContentMode = WebSettings.MIXED_CONTENT_COMPATIBILITY_MODE&#10;                }&#10;            }&#10;&#10;            webView.isVerticalScrollBarEnabled = false&#10;            webView.isHorizontalScrollBarEnabled = false&#10;&#10;            // Fallback handler: timeout&#10;            val mainHandler = Handler(Looper.getMainLooper())&#10;            val timeoutRunnable = Runnable {&#10;                if (!deferred.isCompleted) {&#10;                    deferred.completeExceptionally(TimeoutException(&quot;WebView render timeout&quot;))&#10;                    try {&#10;                        webView.stopLoading()&#10;                        webView.loadUrl(&quot;about:blank&quot;)&#10;                        webView.removeAllViews()&#10;                        webView.destroy()&#10;                    } catch (_: Throwable) {&#10;                    }&#10;                }&#10;            }&#10;            mainHandler.postDelayed(timeoutRunnable, RENDER_TIMEOUT_MS)&#10;&#10;            webView.webViewClient = object : WebViewClient() {&#10;                override fun onRenderProcessGone(view: WebView?, detail: RenderProcessGoneDetail?): Boolean {&#10;                    // WebView's renderer process crashed; fail fast and cleanup&#10;                    try {&#10;                        if (!deferred.isCompleted) {&#10;                            deferred.completeExceptionally(RuntimeException(&quot;WebView renderer process gone: ${detail?.didCrash()}&quot;) )&#10;                        }&#10;                    } catch (_: Throwable) {}&#10;                    try {&#10;                        view?.removeAllViews()&#10;                        view?.destroy()&#10;                    } catch (_: Throwable) {}&#10;                    // Returning true means we handled it and WebView is cleaned up&#10;                    return true&#10;                }&#10;&#10;                override fun onPageFinished(view: WebView?, url: String?) {&#10;                    super.onPageFinished(view, url)&#10;                    try {&#10;                        // get content height (in CSS px) and devicePixelRatio&#10;                        view?.evaluateJavascript(&#10;                            &quot;(function(){return {h: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight), d: window.devicePixelRatio||1};})()&quot;&#10;                        ) { result -&gt;&#10;                            try {&#10;                                if (result == null) {&#10;                                    deferred.completeExceptionally(RuntimeException(&quot;Empty JS result&quot;))&#10;                                } else {&#10;                                    val cleaned = result.trim()&#10;                                    // parse json result&#10;                                    val obj = JSONObject(cleaned)&#10;                                    val cssHeight = obj.optInt(&quot;h&quot;, 0)&#10;                                    val dpr = obj.optDouble(&quot;d&quot;, 1.0).toFloat()&#10;&#10;                                    val contentHeightPx = (cssHeight * dpr).toInt()&#10;&#10;                                    var widthPx = targetWidthPx.coerceAtMost(MAX_WIDTH_PX)&#10;                                    var heightPx = contentHeightPx.coerceAtMost(MAX_HEIGHT_PX)&#10;&#10;                                    if (scaleDownIfTooLarge) {&#10;                                        // if content is taller than max, scale down both dimensions proportionally&#10;                                        if (contentHeightPx &gt; MAX_HEIGHT_PX) {&#10;                                            val scale = MAX_HEIGHT_PX.toFloat() / contentHeightPx.toFloat()&#10;                                            widthPx = (widthPx * scale).toInt().coerceAtLeast(1)&#10;                                            heightPx = MAX_HEIGHT_PX&#10;                                        }&#10;                                    } else {&#10;                                        if (contentHeightPx &gt; MAX_HEIGHT_PX) {&#10;                                            deferred.completeExceptionally(RuntimeException(&quot;Rendered content too tall: $contentHeightPx px&quot;))&#10;                                            return@evaluateJavascript&#10;                                        }&#10;                                    }&#10;&#10;                                    try {&#10;                                        // measure &amp; layout&#10;                                        val widthSpec = View.MeasureSpec.makeMeasureSpec(widthPx, View.MeasureSpec.EXACTLY)&#10;                                        val heightSpec = View.MeasureSpec.makeMeasureSpec(heightPx, View.MeasureSpec.EXACTLY)&#10;                                        view.measure(widthSpec, heightSpec)&#10;                                        view.layout(0, 0, widthPx, heightPx)&#10;&#10;                                        // create bitmap and draw&#10;                                        val estimatedBytes = widthPx.toLong() * heightPx.toLong() * BYTES_PER_PIXEL&#10;                                        // crude safety check: avoid allocating beyond a large threshold (~200MB)&#10;                                        if (estimatedBytes &gt; 200L * 1024 * 1024) {&#10;                                            deferred.completeExceptionally(RuntimeException(&quot;Bitmap too large to allocate: bytes=$estimatedBytes&quot;))&#10;                                            return@evaluateJavascript&#10;                                        }&#10;&#10;                                        // Force software layer to avoid GPU-related renderer crashes on some devices&#10;                                        try {&#10;                                            view.setLayerType(View.LAYER_TYPE_SOFTWARE, null)&#10;                                        } catch (_: Throwable) {}&#10;&#10;                                        val bitmap = Bitmap.createBitmap(widthPx, heightPx, Bitmap.Config.ARGB_8888)&#10;                                        val canvas = Canvas(bitmap)&#10;                                        canvas.drawColor(backgroundColor)&#10;                                        view.draw(canvas)&#10;&#10;                                        // finish&#10;                                        deferred.complete(bitmap)&#10;                                    } catch (e: Throwable) {&#10;                                        deferred.completeExceptionally(e)&#10;                                    }&#10;                                }&#10;                            } catch (e: Throwable) {&#10;                                deferred.completeExceptionally(e)&#10;                            } finally {&#10;                                // cleanup WebView to avoid leak&#10;                                try {&#10;                                    mainHandler.removeCallbacks(timeoutRunnable)&#10;                                    view?.stopLoading()&#10;                                    view?.loadUrl(&quot;about:blank&quot;)&#10;                                    view?.removeAllViews()&#10;                                    view?.destroy()&#10;                                } catch (t: Throwable) {&#10;                                    Log.w(TAG, &quot;Error destroying WebView&quot;, t)&#10;                                }&#10;                            }&#10;                        }&#10;                    } catch (e: Throwable) {&#10;                        deferred.completeExceptionally(e)&#10;                    }&#10;                }&#10;            }&#10;&#10;            // load HTML. Use baseUrl null; callers can embed asset references using file:///android_asset/&#10;            webView.loadDataWithBaseURL(null, html, &quot;text/html&quot;, &quot;utf-8&quot;, null)&#10;&#10;        } catch (e: Throwable) {&#10;            deferred.completeExceptionally(e)&#10;        }&#10;&#10;        deferred.await()&#10;    }&#10;&#10;    /**&#10;     * Java/callback friendly API. Runs on Main thread internally but returns on caller thread via callback.&#10;     */&#10;    fun renderHtmlToBitmapAsync(&#10;        context: Context,&#10;        html: String,&#10;        targetWidthPx: Int,&#10;        onResult: (result: Result&lt;Bitmap&gt;) -&gt; Unit&#10;    ) {&#10;        GlobalScope.launch(Dispatchers.Main) {&#10;            try {&#10;                val bmp = renderHtmlToBitmap(context, html, targetWidthPx)&#10;                onResult(Result.success(bmp))&#10;            } catch (e: Throwable) {&#10;                onResult(Result.failure(e))&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>